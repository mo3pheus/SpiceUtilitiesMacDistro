
package spice.tspice;


import java.io.*;
import java.util.*;
import spice.basic.*;
import static spice.basic.DSKDescriptor.*;
import static spice.basic.DSK02.*;
import spice.testutils.JNITestutils;
import spice.testutils.Testutils;


/**
Class TestDSKAlpha provides methods that implement test families for
Alpha DSK high-level geometry native methods of the class CSPICE.

<p>Version 2.0.0 29-DEC-2016 (NJB)
<pre>
   Renamed class. Previous name was TestDSK1.

   Updated expected short error messages for invalid handles.
   These messages now are generated by the handle manager
   subsystem.
</pre>
<p>Version 1.0.0 02-JUL-2014 (NJB)
<pre>
   Changed calls to CSPICE.llgridPl02 to accommodate argument
   list change in that method. The new argument list has a 
   2-dimensional input coordinate grid; the old version of the 
   grid was 1-dimensional. Also loosened tolerance in CSPICE.llgridPl02
   comparison against results from CSPICE.dskx02. Increased
   size of grid used in these tests.
</pre>
<p>Last update was 08-JUN-2014 (NJB)
*/
public class TestDSKAlpha extends Object
{

   //
   // Class constants
   //

   //
   // Class variables
   //


   //
   // Methods
   //

   /**
   Test Units and associated classes.
   */
   public static boolean f_dskg02()

      throws SpiceException
   {
      //
      // Constants
      //

      final String                      DSKPHB    =     "dskg02_phobos.bds";
      final String                      PCK0      =     "dskg02_test.tpc";    
      final String                      SPK0      =     "dskg02_test.bsp";

      final double                      DPMAX     =    Double.MAX_VALUE;
      final double                      DPMIN     =   - DPMAX;
      final double                      DPR       =     CSPICE.dpr();
      final double                      LOOSE     =     1.e-4;
      final double                      RPD       =     CSPICE.rpd();
      final double                      SINGLE    =     1.e-7;
      final double                      MEDTOL    =     1.e-8;
      final double                      TIGHT     =     1.e-12;
      final double                      VTIGHT    =     1.e-14;

      final int                         DLADSZ    =     8;
      final int                         DSKDSZ    =     24;
      final int                         LNSIZE    =     80;
      final int                         MAXPNT    =     2000;
      final int                         MSGLEN    =     401;
      final int                         NCORR     =     5;
      final int                         NTIMES    =     100;
   
      //
      // Local variables
      //
      boolean[]                         found   = new boolean[1];
      boolean                           ok; 
   
      double[]                          alt     = new double[1];
      double                            angdel;
      double[]                          angles  = new double[3];
      double[]                          badrad  = new double[3];
      double[][]                        cylmat  = new double[3][3];
      double[]                          cylvec  = new double[3];
      double[]                          cylCoords = new double[3];
      double[]                          dist    = new double[1];
      double                            distance;
      double                            dlat;
      double                            dlon;
      double[]                          dskdsc  = new double[ DSKDSZ ];
      double[]                          emissn  = new double[1];
      double                            et0;
      double                            et;
      double[][]                        grid    = null;
      double                            lat;
      double[]                          latCoords = new double[3];
      double                            level;
      double[][]                        limbpts = new double[ MAXPNT ][3];
      double                            lon;
      double[]                          lt      = new double[1];
      double[]                          ltsun   = new double[1];
      double[]                          normal  = new double[3];
      double[]                          npoint  = new double[3];
      double[]                          obspos  = new double[3];
      double[]                          phase   = new double[1];
      double                            r;
      double[]                          radii   = new double[3];
      double[]                          raydir  = new double[3];
      double                            sep;
      double[]                          solar   = new double[1];
      double[]                          spoint  = new double[3];
      double[][]                        spoints = new double[ MAXPNT ][3];
      double                            srcang;
      double                            srcdst;
      double[]                          srclt   = new double[1];
      double[]                          srcpos  = new double[3];
      double[]                          srcrad  = new double[3];
      double[]                          srcvec  = new double[3];
      double[]                          srfobs  = new double[3];
      double[]                          srfsun  = new double[3];
      double[]                          srfvec  = new double[3];
      double[]                          sunpos  = new double[3];
      double                            tdelta;
      double                            tol;
      double[]                          trgepc  = new double[1];
      double[]                          trgpos  = new double[3];
      double[][]                        termpts = new double[ MAXPNT ][3];
      double[]                          vertex  = new double[3];
      double                            vlon;
      double                            vr;
      double                            vz;
      double                            vmag;
      double[]                          xalt    = new double[1];
      double[]                          xemissn = new double[1];
      double                            xlat;
      double[]                          xLatCoords = new double[3];
      double                            xlon;
      double[]                          xphase  = new double[1];
      double                            xplat;
      double                            xplon;
      double                            xpr;
      double[]                          xpt     = new double[3];
      double                            xr;
      double                            xsolar;
      double[]                          xspoint = new double[3];

      int[]                             dladsc  = new int[ DLADSZ ];
      int                               dskhan  = 0;
      int                               nlat;
      int                               nlon;
      int                               npoints;
      int[]                             plateID  = new int[ 1 ];
      int[]                             plateIDs = new int[ MAXPNT ];
      int                               spkhan;
      int[]                             xPlateID = new int[ 1 ];

      String                            abcorr;
      String[]                          abcorrs = { "NONE", "CN+S", 
                                                    "CN",   "LT",  "LT+S" };
      String                            emethod;
      String                            fixref;
      String                            kvname;
      String                            obsrvr;
      String                            label;
      String                            method;
      String                            source;
      String                            target;
      String                            title;
      String                            trmtyp;



      //
      //  We enclose all tests in a try/catch block in order to
      //  facilitate handling unexpected exceptions.  Unexpected
      //  exceptions are trapped by the catch block at the end of
      //  the routine; expected exceptions are handled locally by
      //  catch blocks associated with error handling test cases.
      //
      //  Therefore, JNISpice calls that are expected to succeed don't
      //  have any subsequent "chckxc" type calls following them, nor
      //  are they wrapped in in try/catch blocks.
      //
      //  Expected exceptions that are *not* thrown are tested
      //  via a call to {@link spice.testutils.Testutils#dogDidNotBark}.
      //

      try
      {

         JNITestutils.topen ( "f_dskg02" );

         // ***********************************************************
         //
         //    Setup
         //
         // ***********************************************************


         //
         // --------Case-----------------------------------------------
         //
         JNITestutils.tcase ( "Setup: create and load SPK, PCK, LSK files." );

         //
         // Delete the SPK file if it exists.
         //
         ( new File ( SPK0 ) ).delete();

         spkhan = JNITestutils.tstspk( SPK0, true );

         //
         // Keep the PCK after loading it.
         //
         JNITestutils.tstpck( PCK0, true, true );

         JNITestutils.tstlsk();

         //
         // --------Case-----------------------------------------------
         //
         JNITestutils.tcase ( "Setup: create Phobos type 2 DSK file." );

         //
         // Delete the DSK file if it exists.
         //
         ( new File ( DSKPHB ) ).delete();
         
         /*
         System.out.println( "Creating Phobos test DSK..." );
         */
         
         dskhan = JNITestutils.zztboddsk ( DSKPHB,       "Phobos", 
                                           "IAU_PHOBOS", false    );        
         /*
         System.out.println( "Done." );
         */

         dskhan = CSPICE.dasopr ( DSKPHB );
 




         // ***********************************************************
         //
         //    subptPl02 tests
         //
         // ***********************************************************


         // ***********************************************************
         //
         //    subptPl02 error cases
         //
         // ***********************************************************
 
         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subptPl02: error case init." );


         et0     = CSPICE.str2et ( "1990 jan 1" );

         tdelta  = CSPICE.jyear()/10;
         method  = "Intercept";
         obsrvr  = "Mars";
         target  = "Phobos";
         fixref  = "IAU_PHOBOS";
         abcorr  = "NONE";
         et      = 0.0;
  

         try
         {
            //
            // Find the first segment in the Phobos DSK file. 
            //
            CSPICE.dlabfs ( dskhan, dladsc, found );

            ok = JNITestutils.chcksl ( "found", found[0], true );
 
            //
            // Find the sub-observer point on the target.
            //
            method = "wrong";

            CSPICE.subptPl02( dskhan, dladsc, method, target, et,
                              abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(DUBIOUSMETHOD)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(DUBIOUSMETHOD)", ex );
         }

        
         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subptPl02: bad target." );

         try
         {
            //
            // Find the sub-observer point on the target.
            //
            method = "ellipsoid near point";
            target = "x";

            CSPICE.subptPl02( dskhan, dladsc, method, target, et,
                              abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(IDCODENOTFOUND)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(IDCODENOTFOUND)", ex );
         }

        
         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subptPl02: bad observer." );

         try
         {
            //
            // Find the sub-observer point on the target.
            //
            target = "phobos";
            obsrvr = "x";

            CSPICE.subptPl02( dskhan, dladsc, method, target, et,
                              abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(IDCODENOTFOUND)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(IDCODENOTFOUND)", ex );
         }

        
         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subptPl02: target and observer coincide." );

         try
         {
            //
            // Find the sub-observer point on the target.
            //
            target = "phobos";
            obsrvr = target;

            CSPICE.subptPl02( dskhan, dladsc, method, target, et,
                              abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(BODIESNOTDISTINCT)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(BODIESNOTDISTINCT)", ex );
         }


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subptPl02: missing frame definition" );

         /*
         IMPLEMENT LATER
         */

         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subptPl02: bad aberration correction" );

         try
         {
            //
            // Find the sub-observer point on the target.
            //
            target = "Phobos";
            obsrvr = "Mars";
            abcorr = "xxx";

            CSPICE.subptPl02( dskhan, dladsc, method, target, et,
                              abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(NOTSUPPORTED)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(NOTSUPPORTED)", ex );
         }



         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subptPl02: transmission aberration correction" );

         try
         {
            //
            // Find the sub-observer point on the target.
            //
            target = "Phobos";
            obsrvr = "Mars";
            abcorr = "XCN";

            CSPICE.subptPl02( dskhan, dladsc, method, target, et,
                              abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(NOTSUPPORTED)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(NOTSUPPORTED)", ex );
         }




         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subptPl02: no SPK loaded." );

         try
         {
            //
            // Find the sub-observer point on the target.
            //
            abcorr = "NONE";

            CSPICE.spkuef( spkhan );

            CSPICE.subptPl02( dskhan, dladsc, method, target, et,
                              abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(NOLOADEDFILES)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(NOLOADEDFILES)", ex );
         }

         //
         // Restore SPK.
         //
         CSPICE.furnsh ( SPK0 );


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subptPl02: no DSK loaded." );

         try
         {
            //
            // Find the sub-observer point on the target.
            //

            CSPICE.dascls( dskhan );

            CSPICE.subptPl02( dskhan, dladsc, method, target, et,
                              abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(NOSUCHHANDLE)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(NOSUCHHANDLE)", ex );
         }

         //
         // Re-load DSK for a few other tests. 
         //
         dskhan = CSPICE.dasopr( DSKPHB );



         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subptPl02: target radii not in kernel pool." );

         //
         // This init must precede the try/catch block.
         //
         kvname = "BODY401_RADII";

         try
         {
            //
            // Find the sub-observer point on the target.
            //
            radii  = CSPICE.gdpool( kvname, 0, 3 );

            CSPICE.dvpool( kvname );

            CSPICE.subptPl02( dskhan, dladsc, method, target, et,
                              abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(KERNELVARNOTFOUND)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(KERNELVARNOTFOUND)", ex );
         }


         //
         // Restore target radii in kernel pool.
         //
         CSPICE.pdpool( kvname, radii );

         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subptPl02: missing PCK data for target." );


         try
         {
            kvname = "BODY401_PM";

            CSPICE.dvpool( kvname );

            CSPICE.subptPl02( dskhan, dladsc, method, target, et,
                              abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(FRAMEDATANOTFOUND)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(FRAMEDATANOTFOUND)", ex );
         }

         //
         // Restore frame data by re-loading PCK.
         //
         CSPICE.furnsh( PCK0 );



   /* 
   ---- Case ---------------------------------------------------------
   */

   //JNITestutils.tcase ( "subpt_pl02: DSK segment " +
   //                     "doesn't contain data for target" );

   /*
   TO BE IMPLEMENTED LATER 
   */


   /* 
   ---- Case ---------------------------------------------------------
   */
   //JNITestutils.tcase ( "subpt_pl02: DSK segment's data type is not 2" );

   /*
   TO BE IMPLEMENTED LATER 
   */

   /* 
   ---- Case ---------------------------------------------------------
   */
   //JNITestutils.tcase ( "subpt_pl02: ray toward sub-point misses target" );

   /*
   TO BE IMPLEMENTED LATER 
   */




         // ***********************************************************
         //
         //    CSPICE.subptPl02 normal cases
         //
         // ***********************************************************



         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subptPl02: time init." );


         et0     = CSPICE.str2et ( "1990 jan 1" );

         tdelta  = CSPICE.jyear()/10;

         //
         // Find the first segment in the Phobos DSK file. 
         //
         CSPICE.dlabfs ( dskhan, dladsc, found );

         ok = JNITestutils.chcksl ( "found", found[0], true );
 

         //
         // --------Case-----------------------------------------------
         //
 
         for ( int coridx = 0;  coridx < NCORR;  coridx++ )
         {
      
            for ( int timidx = 0;  timidx < NTIMES;  timidx++ )
            {
               et     = et0 + timidx*tdelta;
               abcorr = abcorrs[ coridx ];


               //
               // --------Case-----------------------------------------------
               //
               method  = "Intercept";
               emethod = "Intercept";

               title   = String.format( "subpt_pl02: find sub-Mars point " +
                                        "on Phobos. Method = "             +
                                        "%s. Abcorr = %s. ET = %25.17e",
                                        method,
                                        abcorr,
                                        et                                  );

               JNITestutils.tcase ( title );

               obsrvr  = "Mars";
               target  = "Phobos";
               fixref  = "IAU_PHOBOS";

               //
               // Find the first segment in the Phobos DSK file. 
               //
               CSPICE.dlabfs ( dskhan, dladsc, found );

               ok = JNITestutils.chcksl ( "found", found[0], true );

               //
               // Find the sub-observer point on the target.
               //
               CSPICE.subptPl02 ( dskhan, dladsc, method, 
                                  target, et,     abcorr, 
                                  obsrvr, spoint, alt,    plateID ); 

               //
               // Find the sub-observer point on the target using an
               // ellipsoidal model.
               //
               JNITestutils.subpt ( emethod, target, et,    
                                    abcorr,  obsrvr, xspoint, xalt ); 
 
               //
               // Compare sub-observer points' planetocentric 
               // longitude/latitude.
               //
               latCoords  = CSPICE.reclat ( spoint );
               
               r   = latCoords[0];
               lon = latCoords[1];
               lat = latCoords[2];

               xLatCoords = CSPICE.reclat ( xspoint );
               
               xr  = xLatCoords[0];
               xlon= xLatCoords[1];
               xlat= xLatCoords[2];

               tol = MEDTOL;

               ok  = JNITestutils.chcksd ( "lon", lon, "~/", xlon, tol );
               ok  = JNITestutils.chcksd ( "lat", lat, "~/", xlat, tol );

               //
               // Compare observer altitudes. Make the absolute tolerance
               // 50 cm.
               //
               tol = 5.0e-4;
               ok  = JNITestutils.chcksd ( "alt", alt[0], "~", xalt[0], tol );

               //
               // Check the distance between the points. Tolerance = 50cm.
               //
               tol = 5.0e-4;

               ok  = JNITestutils.chckad(  "spoint", spoint, "~", 
                                                     xspoint, tol );


               //
               // Now perform a more stringent test. Create a ray using
               // the target-observer position and observer-to ellipsoid
               // sub-point vector. See how close the ray-surface intercept 
               // is to the sub-point.
               //
               CSPICE.spkpos ( target, et,     fixref, 
                               abcorr, obsrvr, trgpos, lt );

               Vector3 vTrgPos  = new Vector3( trgpos );
               Vector3 vObsPos  = vTrgPos.negate();
               Vector3 vXSpoint = new Vector3( xspoint );                   
               raydir           = vXSpoint.sub( vObsPos ).toArray();
               obspos           = vObsPos.toArray();
         
               CSPICE.dskx02 ( dskhan,   dladsc, obspos, raydir, 
                               xPlateID, xpt,    found          );

               ok = JNITestutils.chcksl( "xpt found", found[0], true );

               //
               // The intercept should be on the same plate as the sub-point. 
               //
               ok = JNITestutils.chcksi( "plateID", plateID[0], "=", 
                                                    xPlateID[0], 0 );

               //
               // The intercept and the sub-point should be very 
               // close together. 
               //
               tol = 1.e-10;

               ok = JNITestutils.chckad( "xpt", xpt, "~~/", spoint, tol );



               //
               // --------Case-----------------------------------------------
               //
               method  = "Ellipsoid Near Point";
               emethod = "Near Point";

               title   = String.format( "subpt_pl02: find sub-Mars point " +
                                        "on Phobos. Method = "             +
                                        "%s. Abcorr = %s. ET = %25.17e",
                                        method,
                                        abcorr,
                                        et                                  );

               JNITestutils.tcase ( title );

               obsrvr  = "Mars";
               target  = "Phobos";
               fixref  = "IAU_PHOBOS";

               //
               // Find the first segment in the Phobos DSK file. 
               //
               CSPICE.dlabfs ( dskhan, dladsc, found );

               ok = JNITestutils.chcksl ( "found", found[0], true );

               //
               // Find the sub-observer point on the target.
               //
               CSPICE.subptPl02 ( dskhan, dladsc, method, 
                                  target, et,     abcorr, 
                                  obsrvr, spoint, alt,    plateID ); 

               //
               // Find the sub-observer point on the target using an
               // ellipsoidal model.
               //
               JNITestutils.subpt ( emethod, target, et,    
                                    abcorr,  obsrvr, xspoint, xalt ); 
 
               //
               // Compare sub-observer points' planetocentric 
               // longitude/latitude.
               //
               // Note that, due to the fact that the target is triaxial, not
               // even longitudes will agree.
               //
               latCoords  = CSPICE.reclat ( spoint );
               
               r   = latCoords[0];
               lon = latCoords[1];
               lat = latCoords[2];

               xLatCoords = CSPICE.reclat ( xspoint );
               
               xr  = xLatCoords[0];
               xlon= xLatCoords[1];
               xlat= xLatCoords[2];

               tol = LOOSE;

               ok  = JNITestutils.chcksd ( "lon", lon, "~/", xlon, tol );
               ok  = JNITestutils.chcksd ( "lat", lat, "~/", xlat, tol );

               //
               // Compare observer altitudes. 
               //
               tol = 1.e-3;
               ok  = JNITestutils.chcksd ( "alt", alt[0], "~", xalt[0], tol );

               //
               // Check the distance between the points. Tolerance = 50cm.
               //
               tol = 5.0e-4;

               ok  = JNITestutils.chckad(  "spoint", spoint, "~", 
                                                     xspoint, tol );


               //
               // Now perform a more stringent test. Create a ray using
               // the target-observer position and observer-to ellipsoid
               // sub-point vector. See how close the ray-surface intercept 
               // is to the sub-point.
               //
               CSPICE.spkpos ( target, et,     fixref, 
                               abcorr, obsrvr, trgpos, lt );

               vTrgPos  = new Vector3( trgpos );
               vObsPos  = vTrgPos.negate();
               vXSpoint = new Vector3( xspoint );                   
               raydir   = vXSpoint.sub( vObsPos ).toArray();
               obspos   = vObsPos.toArray();
         
               CSPICE.dskx02 ( dskhan,   dladsc, obspos, raydir, 
                               xPlateID, xpt,    found          );

               ok = JNITestutils.chcksl( "xpt found", found[0], true );

               //
               // The intercept should be on the same plate as the sub-point. 
               //
               ok = JNITestutils.chcksi( "plateID", plateID[0], "=", 
                                                    xPlateID[0], 0 );

               //
               // The intercept and the sub-point 
               // should be very close together. 
               //
               tol = TIGHT;

               ok = JNITestutils.chckad( "xpt", xpt, "~~/", spoint, tol );

            }
            //
            // End of time loop.
            //
         }
         //
         // End of aberration correction loop.
         //

 



         // ***********************************************************
         //
         //    subsolPl02 tests
         //
         // ***********************************************************


         // ***********************************************************
         //
         //    subsolPl02 error cases
         //
         // ***********************************************************

 
         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subsolPl02: error case init." );


         et0     = CSPICE.str2et ( "1990 jan 1" );

         tdelta  = CSPICE.jyear()/10;
         method  = "Intercept";
         obsrvr  = "Mars";
         target  = "Phobos";
         fixref  = "IAU_PHOBOS";
         abcorr  = "NONE";
         et      = 0.0;
  

         try
         {
            //
            // Find the first segment in the Phobos DSK file. 
            //
            CSPICE.dlabfs ( dskhan, dladsc, found );

            ok = JNITestutils.chcksl ( "found", found[0], true );
 
            //
            // Find the sub-solar point on the target.
            //
            method = "wrong";

            CSPICE.subsolPl02( dskhan, dladsc, method, target, et,
                               abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(DUBIOUSMETHOD)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(DUBIOUSMETHOD)", ex );
         }

        
         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subsolPl02: bad target." );

         try
         {
            //
            // Find the sub-solar point on the target.
            //
            method = "ellipsoid near point";
            target = "x";

            CSPICE.subsolPl02( dskhan, dladsc, method, target, et,
                               abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(IDCODENOTFOUND)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(IDCODENOTFOUND)", ex );
         }

        
         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subsolPl02: bad observer." );

         try
         {
            //
            // Find the sub-solar point on the target.
            //
            target = "phobos";
            obsrvr = "x";

            CSPICE.subsolPl02( dskhan, dladsc, method, target, et,
                               abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(IDCODENOTFOUND)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(IDCODENOTFOUND)", ex );
         }

        
         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subsolPl02: target and observer coincide." );

         try
         {
            //
            // Find the sub-solar point on the target.
            //
            target = "phobos";
            obsrvr = target;

            CSPICE.subsolPl02( dskhan, dladsc, method, target, et,
                               abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(BODIESNOTDISTINCT)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(BODIESNOTDISTINCT)", ex );
         }


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subsolPl02: missing frame definition" );

         /*
         IMPLEMENT LATER
         */

         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subsolPl02: bad aberration correction" );

         try
         {
            //
            // Find the sub-solar point on the target.
            //
            target = "Phobos";
            obsrvr = "Mars";
            abcorr = "xxx";

            CSPICE.subsolPl02( dskhan, dladsc, method, target, et,
                               abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(NOTSUPPORTED)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(NOTSUPPORTED)", ex );
         }



         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subsolPl02: transmission aberration " +
                              "correction" );

         try
         {
            //
            // Find the sub-solar point on the target.
            //
            target = "Phobos";
            obsrvr = "Mars";
            abcorr = "XCN";

            CSPICE.subsolPl02( dskhan, dladsc, method, target, et,
                               abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(NOTSUPPORTED)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(NOTSUPPORTED)", ex );
         }




         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subsolPl02: no SPK loaded." );

         try
         {
            //
            // Find the sub-solar point on the target.
            //
            abcorr = "NONE";

            CSPICE.unload( SPK0 );

            CSPICE.subsolPl02( dskhan, dladsc, method, target, et,
                               abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(NOLOADEDFILES)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(NOLOADEDFILES)", ex );
         }

         //
         // Restore SPK.
         //
         CSPICE.furnsh ( SPK0 );


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subsolPl02: no DSK loaded." );

         try
         {
            //
            // Find the sub-solar point on the target.
            //


            //
            // DAS can read data from buffered records even after the
            // associated DAS file has been unloaded. To ensure we try
            // to read from the file, we'll pick a surface point for
            // which we don't have buffered topography data.
            //

            Vector3 vSpoint = new Vector3( spoint );
            xspoint         = vSpoint.negate().toArray();

            CSPICE.illumPl02 ( dskhan, dladsc,  target, et+2e4, abcorr,
                               obsrvr, xspoint, phase,  solar,  emissn );

            CSPICE.dascls( dskhan );

            
            CSPICE.subsolPl02( dskhan, dladsc, method, target, et,
                               abcorr, obsrvr, spoint, alt,    plateID );
            
            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(NOSUCHHANDLE)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(NOSUCHHANDLE)", ex );
         }

         //
         // Re-load DSK for a few other tests. 
         //
         dskhan = CSPICE.dasopr( DSKPHB );



         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subsolPl02: target radii not in kernel pool." );

         //
         // This init must precede the try/catch block.
         //
         kvname = "BODY401_RADII";

         try
         {
            //
            // Find the sub-solar point on the target.
            //
            radii  = CSPICE.gdpool( kvname, 0, 3 );

            CSPICE.dvpool( kvname );

            CSPICE.subsolPl02( dskhan, dladsc, method, target, et,
                               abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(KERNELVARNOTFOUND)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(KERNELVARNOTFOUND)", ex );
         }


         //
         // Restore target radii in kernel pool.
         //
         CSPICE.pdpool( kvname, radii );

         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subsolPl02: missing PCK data for target." );


         try
         {
            kvname = "BODY401_PM";

            CSPICE.dvpool( kvname );

            CSPICE.subsolPl02( dskhan, dladsc, method, target, et,
                               abcorr, obsrvr, spoint, alt,    plateID );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(FRAMEDATANOTFOUND)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(FRAMEDATANOTFOUND)", ex );
         }

         //
         // Restore frame data by re-loading PCK.
         //
         CSPICE.furnsh( PCK0 );



   /* 
   ---- Case ---------------------------------------------------------
   */

   //JNITestutils.tcase ( "subsol_pl02: DSK segment doesn't " +
   //                     "contain data for target"             );

   /*
   TO BE IMPLEMENTED LATER 
   */


   /* 
   ---- Case ---------------------------------------------------------
   */
   //JNITestutils.tcase ( "subsol_pl02: DSK segment's data type is not 2" );

   /*
   TO BE IMPLEMENTED LATER 
   */

   /* 
   ---- Case ---------------------------------------------------------
   */
   //JNITestutils.tcase ( "subsol_pl02: ray toward sub-point misses target" );

   /*
   TO BE IMPLEMENTED LATER 
   */




         // ***********************************************************
         //
         //    CSPICE.subsolPl02 normal cases
         //
         // ***********************************************************



         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "subsolPl02: time init." );


         et0     = CSPICE.str2et ( "1990 jan 1" );

         tdelta  = CSPICE.jyear()/10;

         //
         // Find the first segment in the Phobos DSK file. 
         //
         CSPICE.dlabfs ( dskhan, dladsc, found );

         ok = JNITestutils.chcksl ( "found", found[0], true );


         //
         // --------Case-----------------------------------------------
         //
 
         for ( int coridx = 0;  coridx < NCORR;  coridx++ )
         {
      
            for ( int timidx = 0;  timidx < NTIMES;  timidx++ )
            {
               et     = et0 + timidx*tdelta;
               abcorr = abcorrs[ coridx ];


               //
               // --------Case-----------------------------------------------
               //
               method  = "Intercept";
               emethod = "Intercept";

               title   = String.format( "subsol_pl02: find sub-solar point " +
                                        "on Phobos. Method = "             +
                                        "%s. Abcorr = %s. ET = %25.17e",
                                        method,
                                        abcorr,
                                        et                                  );

               JNITestutils.tcase ( title );

               obsrvr  = "Mars";
               target  = "Phobos";
               fixref  = "IAU_PHOBOS";

               //
               // Find the first segment in the Phobos DSK file. 
               //
               CSPICE.dlabfs ( dskhan, dladsc, found );

               ok = JNITestutils.chcksl ( "found", found[0], true );

               //
               // Find the sub-solar point on the target.
               //
               CSPICE.subsolPl02 ( dskhan, dladsc, method, 
                                   target, et,     abcorr, 
                                   obsrvr, spoint, dist,  plateID ); 

               //
               // Find the sub-solar point on the target using an
               // ellipsoidal model.
               //
               JNITestutils.subsol ( emethod, target, et,    
                                     abcorr,  obsrvr, xspoint ); 
 
               //
               // Compare sub-solar points' planetocentric 
               // longitude/latitude.
               //
               latCoords  = CSPICE.reclat ( spoint );
               
               r   = latCoords[0];
               lon = latCoords[1];
               lat = latCoords[2];

               xLatCoords = CSPICE.reclat ( xspoint );
               
               xr  = xLatCoords[0];
               xlon= xLatCoords[1];
               xlat= xLatCoords[2];

               tol = MEDTOL;

               ok  = JNITestutils.chcksd ( "lon", lon, "~/", xlon, tol );
               ok  = JNITestutils.chcksd ( "lat", lat, "~/", xlat, tol );

               //
               // Check the distance between the points. Tolerance = 20cm.
               //
               tol = 2.0e-4;

               ok  = JNITestutils.chckad(  "spoint", spoint, "~", 
                                                     xspoint, tol );

               // 
               // Check the observer-subsolar point distance. We need to
               // call a different CSPICE routine to get an expected value. 
               //
               // Find the sub-solar point on the target using an
               // ellipsoidal model.
               //
               CSPICE.subslr( "Intercept: ellipsoid", 
                              target, et,      fixref, abcorr, 
                              obsrvr, xspoint, trgepc, srfvec ); 
               //
               // Tolerance = 1m. 
               //
               tol = 1.0e-3;

               ok  = JNITestutils.chcksd(  "dist", dist[0], "~", 
                                           CSPICE.vnorm(srfvec), tol );
 

               //
               // --------Case-----------------------------------------------
               //
               method  = "Ellipsoid Near Point";
               emethod = "Near Point";

               title   = String.format( "subsol_pl02: find sub-solar point " +
                                        "on Phobos. Method = "             +
                                        "%s. Abcorr = %s. ET = %25.17e",
                                        method,
                                        abcorr,
                                        et                                  );

               JNITestutils.tcase ( title );

               obsrvr  = "Mars";
               target  = "Phobos";
               fixref  = "IAU_PHOBOS";

               //
               // Find the first segment in the Phobos DSK file. 
               //
               CSPICE.dlabfs ( dskhan, dladsc, found );

               ok = JNITestutils.chcksl ( "found", found[0], true );

               //
               // Find the sub-solar point on the target.
               //
               CSPICE.subsolPl02 ( dskhan, dladsc, method, 
                                  target, et,     abcorr, 
                                  obsrvr, spoint, alt,    plateID ); 

               //
               // Find the sub-solar point on the target using an
               // ellipsoidal model.
               //
               JNITestutils.subsol ( emethod, target, et,    
                                    abcorr,  obsrvr, xspoint ); 
 
               //
               // Compare sub-solar points' planetocentric 
               // longitude/latitude.
               //
               // Note that, due to the fact that the target is triaxial, not
               // even longitudes will agree.
               //
               latCoords  = CSPICE.reclat ( spoint );
               
               r   = latCoords[0];
               lon = latCoords[1];
               lat = latCoords[2];

               xLatCoords = CSPICE.reclat ( xspoint );
               
               xr  = xLatCoords[0];
               xlon= xLatCoords[1];
               xlat= xLatCoords[2];

               tol = LOOSE;

               ok  = JNITestutils.chcksd ( "lon", lon, "~/", xlon, tol );
               ok  = JNITestutils.chcksd ( "lat", lat, "~/", xlat, tol );
 
               //
               // Check the distance between the points. Tolerance = 50cm.
               //
               tol = 5.0e-4;

               ok  = JNITestutils.chckad(  "spoint", spoint, "~", 
                                                     xspoint, tol );

               // 
               // Check the observer-subsolar point distance. We need to
               // call a different CSPICE routine to get an expected value. 
               //
               // Find the sub-solar point on the target using an
               // ellipsoidal model.
               //
               CSPICE.subslr( "Intercept: ellipsoid", 
                              target, et,      fixref, abcorr, 
                              obsrvr, xspoint, trgepc, srfvec ); 
               //
               // Tolerance = 1m. 
               //
               tol = 1.0e-3;

               ok  = JNITestutils.chcksd(  "dist", dist[0], "~", 
                                           CSPICE.vnorm(srfvec), tol );
 
            }
            //
            // End of time loop.
            //
         }
         //
         // End of aberration correction loop.
         //

 

         // ***********************************************************
         //
         //    dskx02 tests
         //
         // ***********************************************************


         // ***********************************************************
         //
         //    dskx02 error cases
         //
         // ***********************************************************
 

         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "dsk02: Direction vector is zero." );

         try
         {
            vertex[0] = 1.e2;
            vertex[1] = 1.e2;
            vertex[2] = 1.e2;

            raydir[0] = 0.0;
            raydir[1] = 0.0;
            raydir[2] = 0.0;


            CSPICE.dskx02( dskhan,  dladsc, vertex, raydir, 
                           plateID, xpt,    found          );
 
            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(RAYISZEROVECTOR)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(RAYISZEROVECTOR)", ex );
         }




         // ***********************************************************
         //
         //    dskx02 normal cases
         //
         // ***********************************************************

         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "dskx02: spear test setup." );

         //
         // Spear test: we'll shoot a set of rays, each having 
         // a vertex far from the target center, at the target. 
         //

         //
         // Find the first segment in the Phobos DSK file. 
         //
         CSPICE.dlabfs ( dskhan, dladsc, found );

         ok = JNITestutils.chcksl ( "found", found[0], true );

         //
         // Get the DSK descriptor from the segment. 
         // Fetch the maximum radius.
         //
         dskdsc = CSPICE.dskgd( dskhan, dladsc );
         r      = dskdsc[ DSKDescriptor.MX3IDX ];

         //
         // Pick a vertex radius much larger than the target radius. 
         //
         r *= 1.e3;

         //
         // Loop over the lat and lon grid. 
         //
         nlat = 20;
         nlon = 50;

         dlat =   Math.PI / (nlat-1);
         dlon = 2*Math.PI / (nlon-1);

         for ( int i = 0;  i < nlat;  i++  )
         {
            lat = Math.PI/2  - i * dlat;

            for ( int j = 0;  j < nlon;  j++ )
            {
               lon = j * dlon;

               //
               // --------Case-----------------------------------------------
               //
               title = String.format ( 
                          "Spear test for lat = %f (deg) and " +
                          "lon = %f (deg).", 
                          lat * DPR, 
                          lon * DPR                );

               JNITestutils.tcase ( title );

               //
               // Create the ray vertex and direction.
               //
               //
               vertex = CSPICE.latrec( r, lon, lat );
 
               Vector3 vVertex = new Vector3( vertex );
        
               raydir          = vVertex.negate().toArray();
               vmag            = vVertex.norm();
             
               //
               // Find the ray-surface intercept. 
               //
               CSPICE.dskx02( dskhan,  dladsc, vertex, raydir, 
                              plateID, xpt,    found           );

               //
               // We expect to always find the intercept. 
               //
               ok = JNITestutils.chcksl( "found", found[0], true );

               if ( found[0] )
               {
                  //
                  // The longitude and latitude of the intercept should match 
                  // those of the vertex.
                  //
                  latCoords = CSPICE.reclat( xpt );
                  xpr       = latCoords[0];
                  xplon     = latCoords[1];
                  xplat     = latCoords[2];

                  if ( xplon - lon > Math.PI )
                  {
                     xplon -= 2*Math.PI;
                  }
                  if ( lon - xplon > Math.PI )
                  {
                     xplon += 2*Math.PI;
                  }

                  //
                  // Longitude is undefined at the poles. Check it for  
                  // all other latitudes.
                  //
                  tol = TIGHT;

                  if (  Math.abs(lat)  <  ( Math.PI/2 - 1.e-6 )  )
                  {
                     ok = JNITestutils.chcksd( "xplon", xplon, "~", lon, tol );
                  }

                  ok  = JNITestutils.chcksd( "xplat", xplat, "~", lat, tol );

                  //
                  // Check the radial position of the intercept. 
                  //
                  Vector3 vXpt    = new Vector3( xpt );
                  Vector3 vSrfvec = vXpt.sub( vVertex );
                  srfvec          = vSrfvec.toArray();

                  tol = MEDTOL;

                  ok  = JNITestutils.chcksd( "xpr", xpr, "~", 
                                          ( vmag - vSrfvec.norm() ), tol );

                  //
                  // Check the outward normal on the intercept plate. It must 
                  // not point more than 90 degrees away from the vertex. 
                  //
                  normal = CSPICE.dskn02( dskhan, dladsc, plateID[0] );
                  sep    = Math.PI - CSPICE.vsep( normal, srfvec  );

                  ok = JNITestutils.chcksd( "sep", sep, "<", Math.PI/2, 0.0 );

               }

          
               //
               // --------Case-----------------------------------------------
               //
               title = String.format ( 
                          "Spear non-intersection test for lat = %f (deg) " +
                          "and lon = %f (deg).", 
                          lat * DPR, 
                          lon * DPR                );

               JNITestutils.tcase ( title );
 
               //
               // Create the ray vertex and direction.
               //
               vertex = CSPICE.latrec( r, lon, lat );

               //
               // The ray direction is parallel to the vertex. 
               //     
               System.arraycopy( vertex, 0, raydir, 0, 3 );
 
               //
               // Find the ray-surface intercept. 
               //             
               CSPICE.dskx02( dskhan,  dladsc, vertex, raydir, 
                              plateID, xpt,    found           );
               //
               // We expect never to find the intercept. 
               //
               ok = JNITestutils.chcksl( "found", found[0], false );   
            }
         }





         // ***********************************************************
         //
         //    llgridPl02 tests
         //
         // ***********************************************************


         // ***********************************************************
         //
         //    llgridPl02 error cases
         //
         // ***********************************************************
 

         //
         // --------Case-----------------------------------------------
         //
         
         /*

         Add bad file handle test when time permits.

         JNITestutils.tcase ( " " );
         */


         // ***********************************************************
         //
         //    llgridPl02 normal cases
         //
         // ***********************************************************

         //
         // --------Case-----------------------------------------------
         //

         JNITestutils.tcase ( "Generate surface points on a 20x40 grid." );


         //
         // Loop over the lat and lon grid. 
         //
   
         //
         // Caution: an odd value of `nlat' may cause grid points to
         // lie on plate boundaries, making plate IDs unpredictable. 
         //
         nlat    = 20;
         nlon    = 40;

         npoints = nlat * nlon;

         dlat    =   Math.PI / (nlat-1);
         dlon    = 2*Math.PI / (nlon-1);

         grid    = new double[npoints][2];         

         int w = 0;

         for ( int i = 0;  i < nlat;  i++  )
         {
            lat = Math.PI/2 - i * dlat;

            for ( int j = 0;  j < nlon;  j++ )
            {
               lon = MEDTOL + j * dlon;

               grid[w][0] = lon;
               grid[w][1] = lat;

               w++;
            }
         }      
 
         //
         // Find the first segment in the Phobos DSK file. 
         //
         CSPICE.dlabfs ( dskhan, dladsc, found );

         ok = JNITestutils.chcksl ( "found", found[0], true );

         //
         // Get the DSK descriptor from the segment. 
         // Fetch the maximum radius.
         //
         dskdsc = CSPICE.dskgd( dskhan, dladsc );
         r      = dskdsc[ DSKDescriptor.MX3IDX ];

         //
         // Pick a vertex radius somewhat larger than the target radius. 
         //
         r *= 2;

         //
         // Generate surface points. 
         //
         CSPICE.llgridPl02 ( dskhan, dladsc,  
                             grid,   spoints, plateIDs );
 

         //
         // Use CSPICE.dskx02 to check the surface points and 
         // plates from llgridPl02. 
         //  
         for ( int k = 0;  k < npoints;  k++ )
         {
            //
            // Find the latitude and longitude corresponding to the ith point. 
            //
            int i    = k / nlon;
            int j    = k % nlon;
      
            xlat = Math.PI/2 - i * dlat;
            xlon = MEDTOL    + j * dlon;

            //
            //---- Case ------------------------------------------------------
            //
            title = String.format( "llgrid_pl02 test for lat = %f (deg) and " +
                                   "lon = %f (deg).", 
                                   xlat * DPR, 
                                   xlon * DPR      );

            JNITestutils.tcase( title );

            vertex = CSPICE.latrec( r, xlon, xlat );
    
            raydir = (new Vector3(vertex)).negate().toArray();   
      
            CSPICE.dskx02( dskhan,   dladsc,  vertex, raydir, 
                           xPlateID, xspoint, found          );

            ok = JNITestutils.chcksl( "found", found[0], true );

            //
            // Check the plate ID for vertices other than those at the poles.
            // At the poles, round-off can generate unpredictable selections
            // of plates constituting the polar caps.
            //
      
            if (  ( i > 0 ) && ( i < (nlat-1) )  ) 
            {
               ok = JNITestutils.chcksi( "plateID", plateIDs[k], "=", 
                                                    xPlateID[0],      0);
            }

            //
            // All of the vertices should be pretty close to what CSPICE.dskx02
            // can generate. 
            //      
            tol = 10 * TIGHT;

            ok = JNITestutils.chckad( "spoint", spoints[k], "~~/",
                                                xspoint,    tol );
         }



         // ***********************************************************
         //
         //    limbPl02 tests
         //
         // ***********************************************************


         // ***********************************************************
         //
         //    limbPl02 error cases
         //
         // ***********************************************************
 
         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "limbPl02: error test setup" );


         et0     = CSPICE.str2et ( "1990 jan 1" );
         et      = et0;

         obsrvr  = "Mars";
         target  = "Phobos";
         fixref  = "IAU_PHOBOS";
         abcorr  = "NONE";
 
         npoints = 3;
         //
         // Find the first segment in the Phobos DSK file. 
         //
         CSPICE.dlabfs ( dskhan, dladsc, found );



         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "limbPl02: bad aberration correction" );

         try
         {
            target = "Phobos";
            obsrvr = "Mars";

            CSPICE.limbPl02( dskhan, dladsc, target,  et,     
                             fixref, "xxx",  obsrvr,  npoints, 
                             trgepc, obspos, limbpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(SPKINVALIDOPTION)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(SPKINVALIDOPTION)", ex );
         }



         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "limbPl02: bad target." );

         try
         {
            CSPICE.limbPl02( dskhan, dladsc, "x",     et,     
                             fixref, abcorr, obsrvr,  npoints, 
                             trgepc, obspos, limbpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(IDCODENOTFOUND)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(IDCODENOTFOUND)", ex );
         }
        

         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "limbPl02: target doesn't match DSK " +
                              "descriptor" );

         try
         {
            CSPICE.limbPl02( dskhan, dladsc, "Saturn",  et,     
                             fixref, abcorr, obsrvr,    npoints, 
                             trgepc, obspos, limbpts,   plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(DSKTARGETMISMATCH)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(DSKTARGETMISMATCH)", ex );
         }


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "limbPl02: bad observer." );

         try
         {
            CSPICE.limbPl02( dskhan, dladsc, target,  et,     
                             fixref, abcorr, "x",     npoints, 
                             trgepc, obspos, limbpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(IDCODENOTFOUND)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(IDCODENOTFOUND)", ex );
         }


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "limbPl02: bad frame center." );

         try
         {
            CSPICE.limbPl02( dskhan,  dladsc, target,  et,     
                             "J2000", abcorr, obsrvr,  npoints, 
                             trgepc,  obspos, limbpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(INVALIDFRAME)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(INVALIDFRAME)", ex );
         }



         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "limbPl02: bad value of npoints" );

         try
         {
            CSPICE.limbPl02( dskhan, dladsc, target,  et,     
                             fixref, abcorr, obsrvr,  0, 
                             trgepc, obspos, limbpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(INVALIDCOUNT)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(INVALIDCOUNT)", ex );
         }

         try
         {
            CSPICE.limbPl02( dskhan, dladsc, target,  et,     
                             fixref, abcorr, obsrvr,  -1, 
                             trgepc, obspos, limbpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(INVALIDCOUNT)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(INVALIDCOUNT)", ex );
         }


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "limbPl02: bad semi-axis lengths." );

         kvname = "BODY401_RADII";

         radii = CSPICE.gdpool ( kvname, 0, 3 );

         System.arraycopy ( radii, 0, badrad, 0, 3 );
         badrad[0] = -1.0;

         CSPICE.pdpool( kvname, badrad );

         try
         {
            CSPICE.limbPl02( dskhan, dladsc, target,  et,     
                             fixref, abcorr, obsrvr,  npoints, 
                             trgepc, obspos, limbpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(DEGENERATECASE)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(DEGENERATECASE)", ex );
         }

         CSPICE.pdpool( kvname, radii );



         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "limbPl02: target radii not in kernel pool." );

         kvname = "BODY401_RADII";

         radii = CSPICE.gdpool ( kvname, 0, 3 );

         CSPICE.dvpool( kvname );

         try
         {
            CSPICE.limbPl02( dskhan, dladsc, target,  et,     
                             fixref, abcorr, obsrvr,  npoints, 
                             trgepc, obspos, limbpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(KERNELVARNOTFOUND)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(KERNELVARNOTFOUND)", ex );
         }

         CSPICE.pdpool( kvname, radii );


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "limbPl02: missing PCK data for target." );

         kvname = "BODY401_PM";

         CSPICE.dvpool( kvname );

         try
         {
            CSPICE.limbPl02( dskhan, dladsc, target,  et,     
                             fixref, abcorr, obsrvr,  npoints, 
                             trgepc, obspos, limbpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(FRAMEDATANOTFOUND)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(FRAMEDATANOTFOUND)", ex );
         }

         CSPICE.pdpool( kvname, radii );

         //
         // Restore PCK.
         //
         CSPICE.furnsh( PCK0 );


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "limbPl02: target and observer coincide." );

         try
         {
            target = "phobos";
            obsrvr = target;

            CSPICE.limbPl02( dskhan, dladsc, target,  et,     
                             fixref, abcorr, obsrvr,  npoints, 
                             trgepc, obspos, limbpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(BODIESNOTDISTINCT)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(BODIESNOTDISTINCT)", ex );
         }

         obsrvr = "Mars";


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "limbPl02: missing frame definition" );

         /*
         IMPLEMENT LATER
         */

  


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "limbPl02: no DSK loaded." );

         try
         {
            CSPICE.dascls( dskhan );

            CSPICE.limbPl02( dskhan, dladsc, target,  et,     
                             fixref, abcorr, obsrvr,  npoints, 
                             trgepc, obspos, limbpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(NOSUCHHANDLE)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(NOSUCHHANDLE)", ex );
         }

         //
         // Re-load DSK for a few other tests. 
         //
         dskhan = CSPICE.dasopr( DSKPHB );




         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "limbPl02: no SPK loaded." );

         try
         {
            abcorr = "NONE";

            CSPICE.unload( SPK0 );

            CSPICE.limbPl02( dskhan, dladsc, target,  et,     
                             fixref, abcorr, obsrvr,  npoints, 
                             trgepc, obspos, limbpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(NOLOADEDFILES)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(NOLOADEDFILES)", ex );
         }

         //
         // Restore SPK.
         //
         CSPICE.furnsh ( SPK0 );



   /* 
   ---- Case ---------------------------------------------------------
   */
   //JNITestutils.tcase ( "limbPl02: DSK segment's data type is not 2" );

   /*
   TO BE IMPLEMENTED LATER 
   */

 


         // ***********************************************************
         //
         //    CSPICE.limbPl02 normal cases
         //
         // ***********************************************************


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "limbPl02: normal case setup" );

         obsrvr  = "Mars";
         target  = "Phobos";
         fixref  = "IAU_PHOBOS";
 
         et0     = CSPICE.str2et ( "1990 jan 1" );
         et      = et0;
         tdelta  = CSPICE.jyear()/10;

         npoints = 10;

         //
         // Find the first segment in the Phobos DSK file. 
         //
         CSPICE.dlabfs ( dskhan, dladsc, found );

         ok = JNITestutils.chcksl ( "found", found[0], true );



         //
         // --------Case-----------------------------------------------
         //

         for ( int coridx = 0;  coridx < NCORR;  coridx++ )
         {
      
            for ( int timidx = 0;  timidx < NTIMES;  timidx++ )
            {
               et     = et0 + timidx*tdelta;

               abcorr = abcorrs[ coridx ];

               //
               // --------Case-----------------------------------------------
               //
               title = String.format ( 
                   "limb_pl02: with Mars as a viewing location, "  +
                   "find a set of limb points on Phobos. "         +
                   "Abcorr = %s. ET = %25.17e.",
                   abcorr,
                   et             );

               JNITestutils.tcase( title);

               // 
               // Compute a set of limb points for the current 
               // viewing geometry.
               //
               CSPICE.limbPl02( dskhan, dladsc, target,  et, 
                                fixref, abcorr, obsrvr,  npoints, 
                                trgepc, obspos, limbpts, plateIDs );
               //
               // We'll first check the limb points by mapping each one to
               // the "intercept" near point on the reference ellipsoid.
               // Those near points should have emission angles very close
               // to 90 degrees.
               //
               // For the test plate model we're using, the near points and
               // the corresponding limb points should be close together.
               //

               for ( int k = 0;  k < npoints;  k++ )
               {
                  //
                  // Find the level surface parameter of the limb point. 
                  //
                  level =    Math.pow(  limbpts[k][0]/radii[0],  2 )
                          +  Math.pow(  limbpts[k][1]/radii[1],  2 )
                          +  Math.pow(  limbpts[k][2]/radii[2],  2 );

                  //
                  // We have a severe error if the limb point level
                  // is non-positive.
                  //
                  if ( level <= 0.0 ) 
                  {
                     String excMessage = String.format (
                        "Limb point level should be strictly " +
                        "positive but was %e. Index was %d.", 
                        level,
                        k                                       );

                     throw ( new SpiceException( excMessage ) );
                  }

                  //
                  // Find the intercept point on the reference ellipsoid of
                  // the ray emanating from the origin and containing the 
                  // limb point.
                  //         
                  Vector3 vtemp = new Vector3 ( limbpts[k] );
           
                  npoint = vtemp.scale( 1.0 / Math.sqrt(level) ).toArray();


                  // 
                  // Check the distance between the limb point and the 
                  // near point. Look for agreement at the 1 meter level. 
                  //
                  tol      = 1.e-3;

                  distance = CSPICE.vdist( limbpts[k], npoint );

                  label = String.format( "dist %d", k );

                  ok    = JNITestutils.chcksd( label, distance, "~", 0.0, tol );

                  //
                  // Find the illumination angles at the ellipsoid near point. 
                  // We use JNITestutils.illum rather than CSPICE.ilumin
                  // for compatibility of light time computations.
                  //
                  JNITestutils.illum( target, et,     abcorr, 
                                      obsrvr, npoint, angles );

                  emissn[0] = angles[2];

                  //
                  // Presuming we have the correct point on the ellipsoid,
                  // the emission angle should be very close to pi/2. 
                  //
                  tol   = 1.e-10;

                  label = String.format( "emissn %d", k );

                  ok    = JNITestutils.chcksd ( label,     emissn[0], "~/", 
                                                Math.PI/2, tol            );

                  //   
                  // Now check the plate returned along with the limb point.
                  // We can use llgridPl02 to generate an expected plate ID.
                  //
                  // We don't expect plate IDs to match for points at the 
                  // poles, but we probably won't have any limb points at 
                  // the poles. The test will need to be updated if any 
                  // such points are found.
                  //
                  xLatCoords = CSPICE.reclat( limbpts[k] );
                  xr   = xLatCoords[0];
                  xlon = xLatCoords[1];
                  xlat = xLatCoords[2];

                  /*
                  System.out.format( "Lon (deg) = %f; lat (deg) = %f%n",
                                      xlon * CSPICE.dpr(), xlat*CSPICE.dpr() );
                  */

                  grid = new double[1][2];
                  
                  grid[0][0] = xlon;
                  grid[0][1] = xlat;
                  
                  CSPICE.llgridPl02 ( dskhan,  dladsc,  grid, 
                                      spoints, xPlateID         );

                  label = String.format( "plateID %d", k );
                  
                  ok    = JNITestutils.chcksi( label, plateIDs[k], "=", 
                                                      xPlateID[0],  0   ); 
               }

               //
               // Check the angular spacing of the limb points about
               // the observer-target center line. The spacing should be
               // uniform.
               //
               // We'll need a reference frame having its z-axis parallel
               // to the observer-target vector.
               //
               CSPICE.spkpos( target, et, fixref, abcorr, obsrvr, trgpos, lt );

               Vector3 vTrgPos = new Vector3( trgpos );
               Vector3 vObsPos = vTrgPos.negate();
               obspos          = vObsPos.toArray();


               cylmat = CSPICE.twovec( obspos, 3, limbpts[0], 1 );

               angdel = 2*Math.PI / npoints;

               for ( int k = 0;  k < npoints;  k++ )
               {
                  Matrix33 xform = new Matrix33( cylmat     );
                  Vector3  v     = new Vector3 ( limbpts[k] );

                  cylvec    = xform.mxv( v ).toArray();
                  cylCoords = CSPICE.reccyl( cylvec );

                  vlon = cylCoords[1];

                  xlon = k * angdel;

                  if ( xlon-vlon > Math.PI )
                  {
                     xlon -= 2*Math.PI;
                  }
                  else if ( vlon-xlon > Math.PI )
                  {
                     xlon += 2*Math.PI;              
                  }

                  label = String.format( "vlon %d", (long)k );

                  tol = VTIGHT;

                  ok  = JNITestutils.chcksd( label, vlon, "~", xlon, tol );
               }
 
            }
            //
            // End of time loop.
            //
         }
         //
         // End of aberration correction loop.
         //





         // ***********************************************************
         //
         //    termPl02 tests
         //
         // ***********************************************************


         // ***********************************************************
         //
         //    termPl02 error cases
         //
         // ***********************************************************
 


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "termPl02: error test setup" );


         et0     = CSPICE.str2et ( "1990 jan 1" );
         et      = et0;

         source  = "Sun";
         trmtyp  = "UMBRAL";
         obsrvr  = "Mars";
         target  = "Phobos";
         fixref  = "IAU_PHOBOS";
         abcorr  = "NONE";
 
         npoints = 3;
         //
         // Find the first segment in the Phobos DSK file. 
         //
         CSPICE.dlabfs ( dskhan, dladsc, found );

 
         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "termPl02: bad terminator type" );

         try
         {
            target = "Phobos";
            obsrvr = "Mars";

            CSPICE.termPl02( dskhan, dladsc, "xxx",   source, target,  et,     
                             fixref, abcorr, obsrvr,  npoints, 
                             trgepc, obspos, termpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(NOTSUPPORTED)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(NOTSUPPORTED)", ex );
         }

         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "termPl02: bad aberration correction" );

         try
         {
            target = "Phobos";
            obsrvr = "Mars";

            CSPICE.termPl02( dskhan, dladsc, trmtyp, source, target,  et,     
                             fixref, "xxx",  obsrvr,  npoints, 
                             trgepc, obspos, termpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(SPKINVALIDOPTION)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(SPKINVALIDOPTION)", ex );
         }



         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "termPl02: bad source." );

         try
         {
            CSPICE.termPl02( dskhan, dladsc, trmtyp,  "x",     abcorr,  et,     
                             fixref, abcorr, obsrvr,  npoints, 
                             trgepc, obspos, termpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(IDCODENOTFOUND)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(IDCODENOTFOUND)", ex );
         }
        



         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "termPl02: bad target." );

         try
         {
            CSPICE.termPl02( dskhan, dladsc, trmtyp, source, "x",     et,     
                             fixref, abcorr, obsrvr,  npoints, 
                             trgepc, obspos, termpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(IDCODENOTFOUND)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(IDCODENOTFOUND)", ex );
         }
        


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "termPl02: target doesn't match DSK " +
                              "descriptor" );

         try
         {
            CSPICE.termPl02( dskhan, dladsc, trmtyp, source, "Saturn",  et,     
                             fixref, abcorr, obsrvr,    npoints, 
                             trgepc, obspos, termpts,   plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(DSKTARGETMISMATCH)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(DSKTARGETMISMATCH)", ex );
         }


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "termPl02: bad observer." );

         try
         {
            CSPICE.termPl02( dskhan, dladsc, trmtyp, source, target,  et,     
                             fixref, abcorr, "x",     npoints, 
                             trgepc, obspos, termpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(NOTRANSLATION)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(NOTRANSLATION)", ex );
         }


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "termPl02: bad frame center." );

         try
         {
            CSPICE.termPl02( dskhan,  dladsc, trmtyp, source, target,  et,     
                             "J2000", abcorr, obsrvr,  npoints, 
                             trgepc,  obspos, termpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(INVALIDFIXREF)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(INVALIDFIXREF)", ex );
         }



         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "termPl02: bad value of npoints" );

         try
         {
            CSPICE.termPl02( dskhan, dladsc, trmtyp, source, target,  et,     
                             fixref, abcorr, obsrvr,  0, 
                             trgepc, obspos, termpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(INVALIDCOUNT)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(INVALIDCOUNT)", ex );
         }

         try
         {
            CSPICE.termPl02( dskhan, dladsc, trmtyp, source, target,  et,     
                             fixref, abcorr, obsrvr,  -1, 
                             trgepc, obspos, termpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(INVALIDCOUNT)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(INVALIDCOUNT)", ex );
         }


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "termPl02: bad semi-axis lengths." );

         kvname = "BODY401_RADII";

         radii = CSPICE.gdpool ( kvname, 0, 3 );

         System.arraycopy ( radii, 0, badrad, 0, 3 );
         badrad[0] = -1.0;

         CSPICE.pdpool( kvname, badrad );

         try
         {
            CSPICE.termPl02( dskhan, dladsc, trmtyp, source, target,  et,     
                             fixref, abcorr, obsrvr,  npoints, 
                             trgepc, obspos, termpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(INVALIDAXISLENGTH)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(INVALIDAXISLENGTH)", ex );
         }

         CSPICE.pdpool( kvname, radii );



         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "termPl02: source radii not in kernel pool." );

         kvname = "BODY10_RADII";

         radii = CSPICE.gdpool ( kvname, 0, 3 );

         CSPICE.dvpool( kvname );

         try
         {
            CSPICE.termPl02( dskhan, dladsc, trmtyp, source, target,  et,     
                             fixref, abcorr, obsrvr,  npoints, 
                             trgepc, obspos, termpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(KERNELVARNOTFOUND)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(KERNELVARNOTFOUND)", ex );
         }

         CSPICE.pdpool( kvname, radii );




         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "termPl02: target radii not in kernel pool." );

         kvname = "BODY401_RADII";

         radii = CSPICE.gdpool ( kvname, 0, 3 );

         CSPICE.dvpool( kvname );

         try
         {
            CSPICE.termPl02( dskhan, dladsc, trmtyp, source, target,  et,     
                             fixref, abcorr, obsrvr,  npoints, 
                             trgepc, obspos, termpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(KERNELVARNOTFOUND)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(KERNELVARNOTFOUND)", ex );
         }

         CSPICE.pdpool( kvname, radii );


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "termPl02: missing PCK data for target." );

         kvname = "BODY401_PM";

         CSPICE.dvpool( kvname );

         try
         {
            CSPICE.termPl02( dskhan, dladsc, trmtyp, source, target,  et,     
                             fixref, abcorr, obsrvr,  npoints, 
                             trgepc, obspos, termpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(FRAMEDATANOTFOUND)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(FRAMEDATANOTFOUND)", ex );
         }

         CSPICE.pdpool( kvname, radii );

         //
         // Restore PCK.
         //
         CSPICE.furnsh( PCK0 );



         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "termPl02: missing frame definition" );

         /*
         IMPLEMENT LATER
         */

  


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "termPl02: no DSK loaded." );

         try
         {
            CSPICE.dascls( dskhan );

            CSPICE.termPl02( dskhan, dladsc, trmtyp, source, target,  et,     
                             fixref, abcorr, obsrvr,  npoints, 
                             trgepc, obspos, termpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(NOSUCHHANDLE)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(NOSUCHHANDLE)", ex );
         }

         //
         // Re-load DSK for a few other tests. 
         //
         dskhan = CSPICE.dasopr( DSKPHB );




         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "termPl02: no SPK loaded." );

         try
         {
            abcorr = "NONE";

            CSPICE.unload( SPK0 );

            CSPICE.termPl02( dskhan, dladsc, trmtyp, source, target,  et,     
                             fixref, abcorr, obsrvr,  npoints, 
                             trgepc, obspos, termpts, plateIDs  );

            //
            // If an exception is *not* thrown, we'll hit this call.
            //

            Testutils.dogDidNotBark (  "SPICE(NOLOADEDFILES)" );

         }
         catch ( SpiceException ex )
         {
            ok = JNITestutils.chckth ( true,  "SPICE(NOLOADEDFILES)", ex );
         }

         //
         // Restore SPK.
         //
         CSPICE.furnsh ( SPK0 );



   /* 
   ---- Case ---------------------------------------------------------
   */
   //JNITestutils.tcase ( "termPl02: DSK segment's data type is not 2" );

   /*
   TO BE IMPLEMENTED LATER 
   */

 

         // ***********************************************************
         //
         //    CSPICE.termPl02 normal cases
         //
         // ***********************************************************


         //
         // --------Case-----------------------------------------------
         //
         
         JNITestutils.tcase ( "termPl02: normal case setup" );

         source  = "Sun";
         obsrvr  = "Mars";
         target  = "Phobos";
         fixref  = "IAU_PHOBOS";
 
         et0     = CSPICE.str2et ( "1990 jan 1" );
         et      = et0;
         tdelta  = CSPICE.jyear()/10;

         npoints = 10;

         srcrad  = CSPICE.gdpool( "BODY10_RADII", 0, 3 );

         //
         // Find the first segment in the Phobos DSK file. 
         //
         CSPICE.dlabfs ( dskhan, dladsc, found );

         ok = JNITestutils.chcksl ( "found", found[0], true );



         //
         // --------Case-----------------------------------------------
         //

         // 
         // Generate umbral terminators as seen from a fixed observer, for a
         // sequence of input times.
         //
         trmtyp  = "UMBRAL";

         for ( int coridx = 0;  coridx < NCORR;  coridx++ )
         {
      
            for ( int timidx = 0;  timidx < NTIMES;  timidx++ )
            {
               et     = et0 + timidx*tdelta;

               abcorr = abcorrs[ coridx ];

               //
               // --------Case-----------------------------------------------
               //
               title = String.format ( 
                   "term_pl02: with Mars as a viewing location, "  +
                   "find a set of terminator points on Phobos. "         +
                   "Abcorr = %s. ET = %25.17e.",
                   abcorr,
                   et             );

               JNITestutils.tcase( title);

               // 
               // Compute a set of terminator points for the current 
               // viewing geometry.
               //
               CSPICE.termPl02( dskhan, dladsc, trmtyp, source, target,  et, 
                                fixref, abcorr, obsrvr,  npoints, 
                                trgepc, obspos, termpts, plateIDs );
               //
               // We'll first check the terminator points by mapping each one
               // to the "intercept" near point on the reference ellipsoid.
               // Those near points should have solar incidence angles 
               // very close to 90 degrees plus the angular radius of the
               // light source.
               //
               // For the test plate model we're using, the near points and
               // the corresponding terminator points should be close together.
               //

               for ( int k = 0;  k < npoints;  k++ )
               {
                  //
                  // Find the level surface parameter of the terminator point. 
                  //
                  level =    Math.pow(  termpts[k][0]/radii[0],  2 )
                          +  Math.pow(  termpts[k][1]/radii[1],  2 )
                          +  Math.pow(  termpts[k][2]/radii[2],  2 );

                  //
                  // We have a severe error if the terminator point level
                  // is non-positive.
                  //
                  if ( level <= 0.0 ) 
                  {
                     String excMessage = String.format (
                        "terminator point level should be strictly " +
                        "positive but was %e. Index was %d.", 
                        level,
                        k                                       );

                     throw ( new SpiceException( excMessage ) );
                  }

                  //
                  // Find the intercept point on the reference ellipsoid of
                  // the ray emanating from the origin and containing the 
                  // terminator point.
                  //         
                  Vector3 vtemp = new Vector3 ( termpts[k] );
           
                  npoint = vtemp.scale( 1.0 / Math.sqrt(level) ).toArray();


                  // 
                  // Check the distance between the terminator point and the 
                  // near point. Look for agreement at the 1 meter level. 
                  //
                  tol      = 1.e-3;

                  distance = CSPICE.vdist( termpts[k], npoint );

                  label = String.format( "dist %d", k );

                  ok    = JNITestutils.chcksd( label, distance, "~", 
                                                      0.0, tol );

                  //
                  // Find the illumination angles at the ellipsoid near point. 
                  // We use JNITestutils.illum rather than CSPICE.ilumin
                  // for compatibility of light time computations.
                  //
                  JNITestutils.illum( target, et,     abcorr, 
                                      obsrvr, npoint, angles );

                  solar[0] = angles[1];

                  // 
                  // Estimate the angular radius of the light source as
                  // seen from the terminator point.
                  //
                             
                  CSPICE.spkpos( target, et,     fixref, abcorr, 
                                 obsrvr, trgpos, lt             );

                  if ( coridx == 0 ) 
                  {
                     trgepc[0] = et;
                  }
                  else
                  {
                     trgepc[0] = et - lt[0];
                  }

                  CSPICE.spkpos ( source, trgepc[0], fixref, 
                                  abcorr, target,    srcpos, srclt );

                  Vector3 vSrcPos = new Vector3( srcpos  );
                  Vector3 vNpoint = new Vector3( npoint  );
                  Vector3 vSrcVec = vSrcPos.sub( vNpoint );

                  srcdst          = vSrcVec.norm();
                  srcang          = Math.asin ( srcrad[0] / srcdst );

                  //
                  // For points on the umbral terminator, the incidence angle
                  // is increased by approximately the angular radius of the 
                  // light source.
                  //
                  xsolar = Math.PI/2  + srcang;

                  tol    = TIGHT;
        
                  //
                  // Presuming we have the correct point on the ellipsoid,
                  // the solar incidence angle should be very close to
                  // `xsolar'.
                  //
                  label = String.format( "solar %d", k );

                  ok    = JNITestutils.chcksd ( label,  solar[0], "~/", 
                                                xsolar, tol            );

                  //   
                  // Now check the plate returned along with the terminator 
                  // point. We can use llgridPl02 to generate an expected 
                  // plate ID.
                  //
                  // We don't expect plate IDs to match for points at the 
                  // poles, but we probably won't have any terminator points at 
                  // the poles. The test will need to be updated if any 
                  // such points are found.
                  //
                  xLatCoords = CSPICE.reclat( termpts[k] );
                  xr   = xLatCoords[0];
                  xlon = xLatCoords[1];
                  xlat = xLatCoords[2];

                  /*
                  System.out.format( "Lon (deg) = %f; lat (deg) = %f%n",
                                      xlon * CSPICE.dpr(), xlat*CSPICE.dpr() );
                  */

                  grid = new double[1][2];
                
                  grid[0][0] = xlon;
                  grid[0][1] = xlat;
                  

                  CSPICE.llgridPl02 ( dskhan,  dladsc,  grid, 
                                      spoints, xPlateID         );

                  label = String.format( "plateID %d", k );
                  
                  ok    = JNITestutils.chcksi( label, plateIDs[k], "=", 
                                                      xPlateID[0],  0   ); 
               }
            }
            //
            // End of time loop.
            //
         }
         //
         // End of aberration correction loop.
         //



         //
         // --------Case-----------------------------------------------
         //

         // 
         // Generate penumbral terminators as seen from a fixed observer, for a
         // sequence of input times.
         //
         trmtyp  = "PENUMBRAL";



         for ( int coridx = 0;  coridx < NCORR;  coridx++ )
         {
      
            for ( int timidx = 0;  timidx < NTIMES;  timidx++ )
            {
               et     = et0 + timidx*tdelta;

               abcorr = abcorrs[ coridx ];

               //
               // --------Case-----------------------------------------------
               //
               title = String.format ( 
                   "term_pl02: with Mars as a viewing location, "  +
                   "find a set of terminator points on Phobos. "   +
                   "Abcorr = %s. ET = %25.17e.",
                   abcorr,
                   et             );

               JNITestutils.tcase( title);

               // 
               // Compute a set of terminator points for the current 
               // viewing geometry.
               //
               CSPICE.termPl02( dskhan, dladsc, trmtyp, source, target,  et, 
                                fixref, abcorr, obsrvr,  npoints, 
                                trgepc, obspos, termpts, plateIDs );
               //
               // We'll first check the terminator points by mapping each one
               // to the "intercept" near point on the reference ellipsoid.
               // Those near points should have solar incidence angles very 
               // close to 90 degrees minus the angular radius of the light 
               // source.
               //
               // For the test plate model we're using, the near points and
               // the corresponding terminator points should be close together.
               //

               for ( int k = 0;  k < npoints;  k++ )
               {
                  //
                  // Find the level surface parameter of the terminator point. 
                  //
                  level =    Math.pow(  termpts[k][0]/radii[0],  2 )
                          +  Math.pow(  termpts[k][1]/radii[1],  2 )
                          +  Math.pow(  termpts[k][2]/radii[2],  2 );

                  //
                  // We have a severe error if the terminator point level
                  // is non-positive.
                  //
                  if ( level <= 0.0 ) 
                  {
                     String excMessage = String.format (
                        "terminator point level should be strictly " +
                        "positive but was %e. Index was %d.", 
                        level,
                        k                                       );

                     throw ( new SpiceException( excMessage ) );
                  }

                  //
                  // Find the intercept point on the reference ellipsoid of
                  // the ray emanating from the origin and containing the 
                  // terminator point.
                  //         
                  Vector3 vtemp = new Vector3 ( termpts[k] );
           
                  npoint = vtemp.scale( 1.0 / Math.sqrt(level) ).toArray();


                  // 
                  // Check the distance between the terminator point and the 
                  // near point. Look for agreement at the 1 meter level. 
                  //
                  tol      = 1.e-3;

                  distance = CSPICE.vdist( termpts[k], npoint );

                  label = String.format( "dist %d", k );

                  ok    = JNITestutils.chcksd( label, distance, "~", 
                                                      0.0, tol );

                  //
                  // Find the illumination angles at the ellipsoid near point. 
                  // We use JNITestutils.illum rather than CSPICE.ilumin
                  // for compatibility of light time computations.
                  //
                  JNITestutils.illum( target, et,     abcorr, 
                                      obsrvr, npoint, angles );

                  solar[0] = angles[1];

                  // 
                  // Estimate the angular radius of the light source as
                  // seen from the terminator point.
                  //
                             
                  CSPICE.spkpos( target, et,     fixref, abcorr,  
                                 obsrvr, trgpos, lt             );

                  if ( coridx == 0 ) 
                  {
                     trgepc[0] = et;
                  }
                  else
                  {
                     trgepc[0] = et - lt[0];
                  }

                  CSPICE.spkpos ( source, trgepc[0], fixref, 
                                  abcorr, target,    srcpos, srclt );

                  Vector3 vSrcPos = new Vector3( srcpos  );
                  Vector3 vNpoint = new Vector3( npoint  );
                  Vector3 vSrcVec = vSrcPos.sub( vNpoint );

                  srcdst          = vSrcVec.norm();
                  srcang          = Math.asin ( srcrad[0] / srcdst );

                  //
                  // For points on the penumbral terminator, the incidence angle
                  // is reduced by approximately the angular radius of the 
                  // light source.
                  //
                  xsolar = Math.PI/2  - srcang;

                  tol    = TIGHT;
        
                  //
                  // Presuming we have the correct point on the ellipsoid,
                  // the solar incidence angle should be very close to
                  // `xsolar'.
                  //
                  label = String.format( "solar %d", k );

                  ok    = JNITestutils.chcksd ( label,  solar[0], "~/", 
                                                xsolar, tol            );

                  //   
                  // Now check the plate returned along with the terminator 
                  // point. We can use llgridPl02 to generate an expected 
                  // plate ID.
                  //
                  // We don't expect plate IDs to match for points at the 
                  // poles, but we probably won't have any terminator points at 
                  // the poles. The test will need to be updated if any 
                  // such points are found.
                  //
                  xLatCoords = CSPICE.reclat( termpts[k] );
                  xr   = xLatCoords[0];
                  xlon = xLatCoords[1];
                  xlat = xLatCoords[2];

                  /*
                  System.out.format( "Lon (deg) = %f; lat (deg) = %f%n",
                                      xlon * CSPICE.dpr(), xlat*CSPICE.dpr() );
                  */
                
                  grid = new double[1][2];
  
                  grid[0][0] = xlon;
                  grid[0][1] = xlat;
                  

                  CSPICE.llgridPl02 ( dskhan,  dladsc,   grid, 
                                      spoints, xPlateID         );

                  label = String.format( "plateID %d", k );
                  
                  ok    = JNITestutils.chcksi( label, plateIDs[k], "=", 
                                                      xPlateID[0],  0   ); 
               }
            }
            //
            // End of time loop.
            //
         }
         //
         // End of aberration correction loop.
         //
      }

      catch ( SpiceException ex )
      {
         //
         //  Getting here means we've encountered an unexpected
         //  SPICE exception.  This is analogous to encountering
         //  an unexpected SPICE error in CSPICE.
         //

         ex.printStackTrace();

         ok = JNITestutils.chckth ( false, "", ex );
      }

      finally
      {
         //
         // --------Case-----------------------------------------------
         //
         JNITestutils.tcase ( "Clean up kernels." );


         //
         // Unload and delete our test SPK file. It was last
         // loaded by CSPICE.furnsh (NOT CSPICE.spklef).
         //
         CSPICE.unload( SPK0 );
         ( new File (SPK0) ).delete();

         //
         // Clean up text PCK. 
         // 
         CSPICE.kclear();
         ( new File (PCK0) ).delete();

         //
         // Unload and delete our test Phobos DSK file. 
         //
         CSPICE.dascls( dskhan );
        
         
         ( new File ( DSKPHB) ).delete();
         
      }


      //
      // Retrieve the current test status.
      //
      ok = JNITestutils.tsuccess();

      return ( ok );
   }

}

